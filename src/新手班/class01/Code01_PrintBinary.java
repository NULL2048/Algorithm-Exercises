package 新手班.class01;

import java.io.*;


public class Code01_PrintBinary {
    /*
        一、Java中的类型及底层二进制原理
        在Java中int都默认的是有符号类型，C++有无符号整型，但是Java没有无符号整型数
            • int类型在底层就是一个32位的二进制数
            • long类型在底层就是一个64位的二进制数

        一个数据类型在底层占据的二进制位数越多，这个类型的数的取值范围就越大

        以Java的int类型为例：
        int在底层是占用着32位二进制，按道理说，它的最大值应该是2^32-1，也就是42亿多
        但实际上并不是这样的，因为Java中的int是一个有符号整型数，所以需要拿出最高位来代表正负号。

        所以Java中int的范围是[-2^31,2^31-1]最大值是21亿多，少了一半。一半给正数，一半给复数。

        如果是C++的无符号整型数，那么最大值就是42亿多了，也就是2^32-1（减一是因为最小值是从0开始算起的，而不是从1开始算起的，总共有2^32个数，但是第一个数是0，所以最大的数应该是2^32-1）。

        二、位移
        左移只有不带符号的左移，右移有带符号位的右移，也有不带符号位右移
            • 一个数左移一位，就相当于乘2。用位移来替代乘2效率会更高
        十进制偶数右移一位相当于除以2；但是如果不是偶数，就相当于除以2的结果然后取整

        三、取反操作和反码
        原码，反码，补码，移码这只是对一种数的类型的定义
        而取反，是一种操作，任何二进制数都可以对其进行取反操作

        不要把这两个概念混淆成一个，对一个符号位为0的正数取反，仍然是对每一位进行取反操作，1变0，0变1。比如00000001，取反后的结果就是11111110，符合位和其他位都进行取反操作。
        但是00000001的反码，就还是00000001，是原码保持不变，这个只是符号位为0的数的反码定义而已

        对于符号位为1的数来说，取反操作也是一样的，对所有位进行取反。
        比如10000101，取反后的结果就是01111010，但是10000101的反码就是11111010，符号位需要保持不变，其他位进行取反。

        四、相反数
        一个数的相反数，就是对这个数每一位进行取反（这里取反包括对符号位取反），然后将结果+1。这仅仅是一种计算机底层的规定，并不是一个数学规定。
        只是计算机在底层就规定了，将一个数取反然后+1，将得到的结果就作为计算机底层二进制表达这个数的相反数。非负数和负数都使用相同的计算方法。

        我们可以这样看，比如11111011，这个数是-5，我们先看计算它的相反数的过程，先取反，得到00000100，然后再+1，得到00000101，这个数我们很容易就能看出是5。

        然后再计算00000101，也就是5的相反数，先进行取反，得到11111010，然后再+1，得到11111011，也就是-5。

        要注意的就是符号位，符号位不光能表示符号，它本身也是这个数的一部分，所以也要参与进相反数计算当中。

        4.1对数据类型的最小值进行取相反数
        如果将一个有符号数据类型的最小值，我们通过相同的方法来计算相反数的话，会出现问题，我们会发现计算得到的结果和原数一样。

        以int为例，数据范围是[-2^31,2^31-1]，我们可以看出来在非负数区间中，我们取一个相反数，都能在负数区间中找到对应，即使是最大值也不例外。
        但是在负数区间中，并不是所有的数取相反数都能在非负区间中找到对应的数。
        最小值-2^31就找不到在非负区间对应的相反数，因为我们发现最大值2^31-1其实比最小值-2^31的绝对值小1的，所以-2^31取相反数根本就找不到在非负区间中对应的值，因为已经超出了int类型的范围，这个时候，对-2^31取相反数，系统输出的结果还会是-2^31。

        这个我们可以这样理解，因为计算正数的时候，最高位符号位是不可以用的，必须保证最高位永远是0，只能用余下得31位，但是计算负数的时候，最高位除了表示是负数以外，本身也是这个数的一部分，所以最高位是1，其实也就把复数的范围比正数增加了1（其实非负数的最大值再+1，就能向前进一位，但是非负的最高位符号位必须保证是0，所以也就不能用这一位了。
        但是负数就可以用最高位来表示1），也就是计算负数可以用到32位。（换个角度来理解，正数范围除了要表示正数以外，还要表示0，但是负数只需要表示小于0得数就可以了，所以正数需要把一位留给0，最后能表示的最大正数也就会比负数的最小负数的绝对值少1）

        这个现象我们也可以从底层计算原理来找到答案，底层所有的数都是二进制，取二进制相反数就是将其取反，然后+1。我们知道int最小值的二进制形式是10000000（这里省略其他位，其他位都是0），进行取反得到01111111，然后+1，得到10000000，结果和原来一样。

        这种现象就要留意，如果使用int类型之后，后面的代码可能会取int最小值的相反数，这样我们就不能用int类型了，应该改用long类型，避免后面代码出现bug

        4.2对0进行取相反数
        对0取相反数得到的结果还是0。

        00000000来计算相反数，先取反，得到11111111，再+1，这里我们就假定这个数据类型只有8位，所以这里+1之后，向前进位，其实是溢出了。11111111 + 1 = 100000000，最前面那个1已经溢出了，所以要去掉，最后的结果就还是00000000。

        五、如何知道有符号类型的二进制数对应的十进制数是多少
        如果是一个有符号类型，最高位是0的话，说明这个数一定是非负的（正数和0）。最高位是1，这个数为负数。

        5.1 符号位为0
        计算一个符号位为0的二进制数代表十进制数是什么，这个很简单了，符号位为0，所以知道这个数是非负数，直接用这个二进制数进行十进制转化就可以了（注意，转化的时候要带着符号位进行转化，符号位可以用来判断数的正负，但是它也是这个数本身的一部分，所以在转换的时候也要带着一起参与运算）。

        5.2 符号位为1
        计算一个符号位为1的二进制数代表的是什么十进制数，不能直接对这个二进制数进行十进制转换，需要先对这个二进制数进行处理，然后将处理完成之后的二进制数进行十进制转化。

        处理方法：通过符号位是1，我们知道了这个数一定是一个负数，也就是一定是-X这种形式的数，然后我们就要想办法知道X是多少，这个X肯定就是这个数的相反数，所以我们就去计算这个数的相反数就行了。
        我们已经讲过二进制相反数的计算方法了，就是将这个数先取反（取反的时候带着符号位进行取反，因为符号位也是这个数的一部分），再+1，得到的结果就是X代表的二进制数。这样我们就得到了一个正数的二进制数，也就是X代表的二进制数，然后将这个二进制数进行十进制转化就得到了X，进而就知道了-X是多少了。

        总结一下其实就是首先通过符号位为1直到了这个数是一个负数，然后再取这个数的相反数，也就是知道了这个数的绝对值。我们知道了这个数的绝对值，也知道了这个数的符号，自然也就知道这个数代表的是多少了。
        就是要注意的就是符号位，符号位不光能表示符号，它本身也是这个数的一部分，所以也要参与进相反数计算当中。

        举一个例子，11111111，这个是-1的二进制形式
        就是先看到符号位是1，我们知道了这个数是负数，所以这个数一定是-X形式的，然后我们计算这个数的相反数。先进行取反操作，然后再+1。
        但是这里要注意，这个取反操作要带着符号位，符号位也是这个数的一部分，必须参与运算。
        带着符号位取反，得到00000000，然后+1，得到00000001，结果就是X的二进制形式，00000001是个符号位为0的正数，我们很容易就能看出是1，所以11111111就是-1。
     */

    public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));

    public static StreamTokenizer st =new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));

    /**
     * 将int类型的十进制转化为二进制数，并输出
     * @param num
     */
    public static void print(int num) {
        for (int i = 31; i >= 0; i--) {
            // 很好理解，就是按位取与，一位一位的取出二进制数
            out.print((num & (1 << i)) == 0 ? 0 : 1);
        }
        out.println();
    }

    public static void main(String[] args) {
        int num = -5;
        print(num);

        int test = 1123123;
		print(test);
		print(test<<1);
		print(test<<2);
		print(test<<8);

        int a = 12345;
        // ~这个符号就是取反
        int b = ~a;
        print(a);
        print(b);


        System.out.println(Integer.MIN_VALUE);
		System.out.println(Integer.MAX_VALUE);

		int c = 12319283;
		int d = 3819283;
		print(c);
		print(d);
		System.out.println("=============");
		print(c | d);
		print(c & d);
		print(c ^ d);

        int e = Integer.MIN_VALUE;
		print(e);
        // 带符号位右移。右移之后，最左侧的位由符号位去补。如果符号位是0，就补0，符号位值1，就补1
		print(e >> 1);
        // 不带符号位右移。右移之后，用0去补最左侧的位
		print(e >>> 1);


        int f = Integer.MIN_VALUE;
		int g1 = -f ;
        // 一个数的取反 + 1结果就是这个数的相反数
        int g2 = ~f + 1;

        // g1和g2是相等的
        out.println(g1);
        out.println(g2);

        // 对int类型的最小值取相反数，得到的结果和原数一样，这里f和g1一样的
        out.println(f);
        out.print(g1);

        out.flush();
        out.close();
    }
}
