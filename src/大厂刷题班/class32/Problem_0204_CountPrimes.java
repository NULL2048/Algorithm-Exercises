package 大厂刷题班.class32;
// 数学   素数筛选法：埃氏筛选法（埃拉托斯特尼筛法）
// 素数就是除了1和自己以外没有别的因子，规定1不是素数，0也不是素数
// https://leetcode.cn/problems/count-primes/
public class Problem_0204_CountPrimes {
    public int countPrimes(int n) {
        // 如果n小于3，那么一定最多只会判断0和1，因为题意要求了是要判断1~n-1的素数个数，而0和1都不是素数，所以直接返回0
        if (n < 3) {
            return 0;
        }
        // 标记一个数是否为素数，例：j已经不是素数了，那么prime[j] = true;也就是筛选流程结束后，prime数组中所有为false的数就是素数
        // 这个数组中下标只有为奇数的时候是有效的，合数的话就认为除了2以外其他的合数都是非素数
        boolean[] prime = new boolean[n];
        // 所有偶数都不要，还剩几个数。这里是为了统计素数个数，通过剔除非素数来统计的
        // 这是因为我们只有在彻底完成素数筛选后，preme数组为false的才是素数，但是如果素数筛选过程中被标为true的数，它就一定不是素数，我们可以利用这个来做素数的统计，这样就能在筛选结束后少写一个循环来统计素数个数
        int count = n / 2;

        /**
         埃氏筛选法（埃拉托斯特尼筛法）算法描述：
         先把素数2的倍数全部删除，剩下的数第一个素数为3，再把素数3的倍数全部删除，剩下的第一个素数为5，再把素数5的倍数全部删除······
         直到把n以内最后一个素数的倍数删除完毕，就得到n以内的所有素数
         */

        // 跳过了1、2和所有的合，i+=2保证了只关心奇数
        // 只判断奇数3、5、7....等是否为素数，因为合数除了2以外都是非素数（因为他们肯定都会有2这个因子），所以可以不同去判断合数了
        for (int i = 3; i * i < n; i += 2) {
            // 如果这个数在之前的流程中已经确定了不是素数（也就是说已经确定了i存在除了1和本身以外的因子），就不用判断这个数了，直接跳过
            // 我们要找每一轮剩下的数中第一个素数
            if (prime[i]) {
                continue;
            }

            // 此时确定了i是一个素数，那么我们就把i的所有倍数都标记为非素数，因为i的倍数肯定存在i这个因子，所以一定不是素数
            // 下面的操作不是判断合数，因为合数一定都是非素数，所以循环就从i*i开始，然后每一次都加2*i，这样就能保证找的都是素数i的非合数倍数
            // 然后将这些数都标记为非素数即可
            // 3 -> 3 * 3 = 9   3 * 5 = 15   3 * 7 = 21
            // 7 -> 7 * 7 = 49  7 * 9 = 63
            // 13 -> 13 * 13  13 * 15
            //
            for (int j = i * i; j < n; j += 2 * i) {
                // 如果j这个数还没有被标记为非素数，那么我们就去进行标记操作
                // 如果j这个数已经标记为非素数了，那么我们就不再重复统计了
                if (!prime[j]) {
                    // 将素数个数减1，因为剔掉了j这个数
                    --count;
                    // 将j标记为true，表示非素数
                    prime[j] = true;
                }
            }
        }
        // 返回1~n-1范围上素数个数
        return count;
    }
}
