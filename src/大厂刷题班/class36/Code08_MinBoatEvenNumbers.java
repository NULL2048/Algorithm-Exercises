package 大厂刷题班.class36;
import java.util.Arrays;

// 这道题和大厂刷题班第三节课的Code06_BoatsToSavePeople思路是差不多的
// 双指针+贪心    数学

// 来自腾讯
// 给定一个正数数组arr，代表每个人的体重。给定一个正数limit代表船的载重，所有船都是同样的载重量
// 每个人的体重都一定不大于船的载重
// 要求：
// 1, 可以1个人单独一搜船
// 2, 一艘船如果坐2人，两个人的体重相加需要是偶数，且总体重不能超过船的载重
// 3, 一艘船最多坐2人
// 返回如果想所有人同时坐船，船的最小数量
public class Code08_MinBoatEvenNumbers {
    // 下面这个方法由奇数体重数组和偶数体重数组分别调用一次，将得到的结果相加就是这道题的答案
    public static int numRescueBoats2(int[] people, int limit) {
        /**
         * 要使需要的船数尽可能地少，应当使载两人的船尽可能地多。
         设people的长度为n。考虑体重最轻的人：
         1、若他不能与体重最重的人同乘一艘船，那么体重最重的人无法与任何人同乘一艘船，此时应单独分配一艘船给体重最重的人。
         从people中去掉体重最重的人后，我们缩小了问题的规模，变成求解剩余 n−1 个人所需的最小船数，将其加一即为原问题的答案。
         2、若他能与体重最重的人同乘一艘船，那么他能与其余任何人同乘一艘船，为了尽可能地利用船的承载重量，
         选择与体重最重的人同乘一艘船是最优的。从people中去掉体重最轻和体重最重的人后，我们缩小了问题的规模，
         变成求解剩余 n−2 个人所需的最小船数，将其加一即为原问题的答案。

         在代码实现时，我们可以先对people排序，然后用两个指针分别指向体重最轻和体重最重的人，按照上述规则来移动指针，并统计答案。
         */
        int ans = 0;
        Arrays.sort(people);
        // 设置左右指针，分别从数组的左边界和右边界，开始无回退地向中间移动
        int light = 0, heavy = people.length - 1;
        while (light <= heavy) {
            // 如果此时最轻的和最重的人相加小于limit，此时这两个人可以拼一条船，是最优的解
            if (people[light] + people[heavy] <= limit) {
                // 左指针右移
                ++light;
            }
            // 如果如果此时最轻的和最重地人相加大于limit，说明此时最重的这个人和此时最轻的人相加都大于limit了，那么他和其他任何一个人相加都会大于limit，这样它就只能自己乘坐一条船过河了，所以ans++
            // 右指针左移
            --heavy;
            // 增加一条船
            ++ans;
        }
        return ans;
    }
}
