package 大厂刷题班.class36;

import java.util.HashMap;

// 数组   类似于前缀和的思想   数学   分数组织技巧
// 之前讲过的一个直线最大共线问题，这个问题中处理分数的方法和这道题类似，直接用HashMap存分母和分子，避免精度问题，可以直接通过比较分子和分母来确定两个分数是否一致

// 来自京东
// 把一个01字符串切成多个部分，要求每一部分的0和1比例一样，同时要求尽可能多的划分
// 比如 : 01010101
// 01 01 01 01 这是一种切法，0和1比例为 1 : 1
// 0101 0101 也是一种切法，0和1比例为 1 : 1
// 两种切法都符合要求，但是那么尽可能多的划分为第一种切法，部分数为4
// 比如 : 00001111
// 只有一种切法就是00001111整体作为一块，那么尽可能多的划分，部分数为1
// 给定一个01字符串str，假设长度为N，要求返回一个长度为N的数组ans
// 其中ans[i] = str[0...i]这个前缀串，要求每一部分的0和1比例一样，同时要求尽可能多的划分下，部分数是多少
// 输入: str = "010100001"
// 输出: ans = [1, 1, 1, 2, 1, 2, 1, 1, 3]
public class Code02_Ratio01Split {
    // 001010010100...
    public static int[] split(int[] arr) {
        // key : 01比例的分子
        // value : value也是一个HashMap，它其中也有key1和value1，key1是01比例的分母，value1表示此时有多少个满足01比例是key/key1的前缀
        HashMap<Integer, HashMap<Integer, Integer>> pre = new HashMap<>();
        int n = arr.length;
        int[] ans = new int[n];
        int zero = 0; // 0出现的次数
        int one = 0; // 1出现的次数
        // 遍历数组，统计所有前缀的01划分信息
        for (int i = 0; i < n; i++) {
            // 统计此时0~i前缀0、1出现次数
            if (arr[i] == 0) {
                zero++;
            } else {
                one++;
            }

            // 如果此时的前缀仍是存在有0或者1一个都没有，那么划分数就很明确了，有多少个数就划分几部分，题目要求尽可能多的划分，每一部分只有一个相同的数01比例自然相同，满足题目要求
            if (zero == 0 || one == 0) {
                // 0~i前缀最多划分i+1部分
                ans[i] = i + 1;
                // 0和1，都有数量 -> 最简分数
            } else {
                // 求最大公约数，用于化简当前前缀整体的01比例分数
                int gcd = gcd(zero, one);
                int a = zero / gcd;
                int b = one / gcd;
                // 当前0~i整体的01比例最简为a / b
                // 结论一：如果此时整体的01比例为a/b，想要对其进行划分，使得每一部分的01比例都一样的话，那么每一部分的01比例必须要和整体的01比例一样才行，这是一条定理
                // 结论二：并且举个例子如果j<i，0~j的01比例是a/b，整体0~i的01比例是a/b，那么j+1~i的01比例一定也是a/b，这也是一条定理

                // 所以当我们确定了0~i整体的01比例为a/b时，想要知道这个范围最多划分多少个部门能够使每一个部门的01比例一样
                // 首先我们可以确定的是每一个划分出来的部分内部的01比例必须也得是a/b
                // 我们现在只需要找i前面部分有多少个前缀的01比例是a/b，这个个数加1就是当前0~i范围内能划分出来最多的01比例一样的部分数。其实很好理解，就是利用上面的两条定理得到的结论，仔细想一下就明白了

                // 查找此时i前面的所有前缀中，有没有01比例的分子是a的
                if (!pre.containsKey(a)) {
                    // 如果没有，就创建一条新数据加入
                    pre.put(a, new HashMap<>());
                }
                // 去看i前面所有前缀中是否存在01比例是a/b的
                if (!pre.get(a).containsKey(b)) {
                    // 如果之前不存在，现在就找到这一条前缀(0~i)的01比例是a/b，将其记录到map中
                    pre.get(a).put(b, 1);
                    // 存在01比例是a/b的前缀
                } else {
                    // 因为此时向后遍历了一格位置，最终划分出来的符合条件的部分数又多了1个，所以01比例为a/b的部分数在原来基础上加1
                    pre.get(a).put(b, pre.get(a).get(b) + 1);
                }
                // 将结果记录到ans中，0~i范围上划分出满足01比例全都为a/b的最多部分数
                ans[i] = pre.get(a).get(b);
            }
        }
        return ans;
    }

    // 辗转相除法，求最大公约数
    public static int gcd(int m, int n) {
        return n == 0 ? m : gcd(n, m % n);
    }

    public static void main(String[] args) {
        int[] arr = { 0, 1, 0, 1, 0, 1, 1, 0 };
        int[] ans = split(arr);
        for (int i = 0; i < ans.length; i++) {
            System.out.print(ans[i] + " ");
        }
    }

}
